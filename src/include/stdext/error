// Copyright (c) 2019 - Gabriel Cuvillier, Continuation Labs (www.continuation-labs.com)
// Licensed under the MIT License.

#ifndef STDEXT_ERROR_H
#define STDEXT_ERROR_H

// stdext
#include <stdext/compiler_support>
#include <stdext/enum_to_string>

// std
#include <string>        // std::string
#include <system_error>  // std::error_condition, std::error_category
#include <typeinfo>      // typeid

namespace stdext
{
void install_unhandled_exception_handler();

// Enumeration Error Category, parametrized by an error enumeration class
template<typename T>
class EnumErrorCategory : public std::error_category
{
public:
  stdext_NODISCARD static std::error_category const& Singleton()
  {
    static EnumErrorCategory<T> g_category;
    return g_category;
  }

  stdext_NODISCARD const char* name() const noexcept stdext_OVERRIDE { return typeid( T ).name(); }

  stdext_NODISCARD std::string message( int ev ) const stdext_OVERRIDE { return enum_to_string( static_cast<T>( ev ) ); }
};

// OK: alias for "No Error"
const std::error_condition OK;

// InternalError enumeration class
enum class InternalError {
  AssertionFailed = 1  // only "AssertionFailed" for now
};

// Generic error condition creation, parametrized by an error enumeration class
template<typename T>
stdext_NODISCARD std::error_condition make_error_condition( T err )
{
  return std::error_condition{static_cast<int>( err ), EnumErrorCategory<T>::Singleton()};
}

// Specialization of enum_to_string for InternalError enumeration class
template<>
stdext_NODISCARD const char* enum_to_string( InternalError err );

void PRINTERROR( const char* const file, const int line, const char* const func, const char* const message );

template<typename T>
stdext_NODISCARD std::error_condition check_failure( T val,
                                                     const bool silent = false,
                                                     const char* const file = stdext_FILE,
                                                     const int line = stdext_LINE,
                                                     const char* const func = stdext_FUNCTION )
{
  if ( !val ) {
    std::error_condition new_error = make_error_condition( InternalError::AssertionFailed );
    if ( !silent ) {
      PRINTERROR( file, line, func, new_error.message().c_str() );
    }
    return new_error;
  } else {
    return OK;
  }
}

template<>
stdext_NODISCARD inline std::error_condition check_failure( std::error_condition val,
                                                            const bool silent,
                                                            const char* const file,
                                                            const int line,
                                                            const char* const func )
{
  if ( val ) {
    if ( !silent ) {
      PRINTERROR( file, line, func, val.message().c_str() );
    }
  }
  return val;
}

void EPICFAIL_RET();

void EPICFAIL_RET_VOID();

void EPICFAIL_RET_INT();

void EPICFAIL_LOOP();

void EPICFAIL_LOOP_BREAK();

void EPICFAIL_NOP();

}  // namespace stdext

namespace std
{
template<>
struct is_error_condition_enum<stdext::InternalError> : true_type
{
};
}  // namespace std

#define ASSERT( expression )                                              \
  if ( std::error_condition err = stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET();                                               \
    return err;                                                           \
  }
#define ASSERT_DEBUG( expression ) ASSERT( expression )
#define ASSERT_RET_VOID( expression )          \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET_VOID();               \
    return;                                    \
  }
#define ASSERT_RET_ONE( expression )           \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET_INT();                \
    return 1;                                  \
  }
#define ASSERT_RET_ZERO( expression )          \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET_INT();                \
    return 0;                                  \
  }
#define ASSERT_RET_FALSE( expression )         \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET_INT();                \
    return false;                              \
  }
#define ASSERT_RET_NULL( expression )          \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_RET_INT();                \
    return nullptr;                            \
  }
#define ASSERT_LOOP( expression )              \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_LOOP();                   \
    continue;                                  \
  }
#define ASSERT_LOOP_BREAK( expression )        \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_LOOP_BREAK();             \
    break;                                     \
  }
#define ASSERT_NOP( expression )               \
  if ( stdext::check_failure( expression ) ) { \
    stdext::EPICFAIL_NOP();                    \
    (void)0;                                   \
  }

#endif
