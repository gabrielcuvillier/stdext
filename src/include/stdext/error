// Copyright (c) 2019 - Gabriel Cuvillier, Continuation Labs (www.continuation-labs.com)
// Licensed under the MIT License.

#ifndef STDEXT_ERROR_H
#define STDEXT_ERROR_H

// stdext
#include <stdext/compiler_support>

// std
#include <system_error>   // std::error_condition, std::error_category
#include <string>         // std::string
#include <typeinfo>       // typeid

namespace stdext {

void install_unhandled_exception_handler();

// Template function to convert an enumeration error class to a string
// It have to be specialized for new error enumerations classes
template<typename T>
stdext_NODISCARD std::string enum_to_string(T) {
  return std::string{};
}

// Enumeration Error Category, parametrized by an error enumeration class
template<typename T>
class EnumErrorCategory : public std::error_category {
 public:
  stdext_NODISCARD static std::error_category const &Singleton() {
    static EnumErrorCategory<T> g_category;
    return g_category;
  }

  stdext_NODISCARD const char *name() const noexcept override {
    return typeid(T).name();
  }

  stdext_NODISCARD std::string message(int ev) const override {
    return enum_to_string(static_cast<T>(ev));
  }
};

// OK: alias for "No Error"
const std::error_condition OK;

// InternalError enumeration class
enum class InternalError {
  AssertionFailed = 1       // only "AssertionFailed" for now
};

// Generic error condition creation, parametrized by an error enumeration class
template<typename T>
stdext_NODISCARD std::error_condition make_error_condition(T err) {
  return std::error_condition{static_cast<int>(err), EnumErrorCategory<T>::Singleton()};
}

// Specialization of enum_to_string for InternalError enumeration class
template<>
stdext_NODISCARD std::string enum_to_string(InternalError err);

void PRINTERROR(const char *file, int line, const char *func, const char *message);

template<typename T>
stdext_NODISCARD std::error_condition check_failure(T val,
                                                 bool silent = false,
                                                 const char *file = stdext_FILE,
                                                 int const line = stdext_LINE,
                                                 const char *func = stdext_FUNCTION) {
  if (!val) {
    std::error_condition new_error = make_error_condition(InternalError::AssertionFailed);
    if (!silent) {
      PRINTERROR(file, line, func, new_error.message().c_str());
    }
    return new_error;
  } else {
    return OK;
  }
}

template<>
stdext_NODISCARD inline std::error_condition check_failure(std::error_condition val,
                                                        bool silent,
                                                        const char *file,
                                                        int line,
                                                        const char *func) {
  if (val) {
    if (!silent) {
      PRINTERROR(file, line, func, val.message().c_str());
    }
  }
  return val;
}

void EPICFAIL_RET();

void EPICFAIL_RET_VOID();

void EPICFAIL_RET_INT();

void EPICFAIL_LOOP();

void EPICFAIL_LOOP_BREAK();

void EPICFAIL_NOP();

}

namespace std {
template<>
struct is_error_condition_enum<stdext::InternalError> : true_type {
};
}

#define ASSERT(expression)            if (std::error_condition err = stdext::check_failure(expression)) { stdext::EPICFAIL_RET(); return err; }
#define ASSERT_RET_VOID(expression)   if (stdext::check_failure(expression)) { stdext::EPICFAIL_RET_VOID(); return; }
#define ASSERT_RET_ONE(expression)    if (stdext::check_failure(expression)) { stdext::EPICFAIL_RET_INT(); return 1; }
#define ASSERT_RET_ZERO(expression)    if (stdext::check_failure(expression)) { stdext::EPICFAIL_RET_INT(); return 0; }
#define ASSERT_RET_FALSE(expression)    if (stdext::check_failure(expression)) { stdext::EPICFAIL_RET_INT(); return false; }
#define ASSERT_RET_NULL(expression)    if (stdext::check_failure(expression)) { stdext::EPICFAIL_RET_INT(); return nullptr; }
#define ASSERT_LOOP(expression)       if (stdext::check_failure(expression)) { stdext::EPICFAIL_LOOP(); continue; }
#define ASSERT_LOOP_BREAK(expression) if (stdext::check_failure(expression)) { stdext::EPICFAIL_LOOP_BREAK(); break; }
#define ASSERT_NOP(expression)        if (stdext::check_failure(expression)) { stdext::EPICFAIL_NOP(); (void)0; }

#endif
